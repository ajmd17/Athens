module Functions


func globalFunction() {
  print "Hello! I am a global function - at least to this module, I am!"
}

alsoAGlobalFunction = func() {
  print "I am also a global function, declared in a different way, however."
}

// `let` also works but omitting the keyword looks cleaner
let functionWithParameters = func(a, b) {
  print " I am a function with parameters! For `a`, you gave me: ", a, ". As for `b`, you gave me a ", b
}

/*

  These are function types which may be added to the language in the near future.
  They will probably replace what we have now, depending on how it works out.

futureFunctionType = () {
  print "Woah woah woah buddy, where's your `func`?"
}

futureFunctionType2 = (woah, what) {
  print "I don't know mate, where the func is yours?"
  print woah, "\t", what
}

*/

// now, I'll show you a nifty feature of the language.
// say you have an object, like so:
name = "Johnny DirtBag"

// and say you have a function:
doSomething = func(a) {
  print "the value for `a` you gave me is: \"", a, "\""
}

// we can actually use that function /directly/ on the `name` object.
// look and see:

name.doSomething()

// notice how we didn't actually write any parameters in the parentheses?
// that's because the object `name` was passed in instead!

// if `name` happened to have a member function/method/property/what have you called `doSomething`,
// that would take precedence and would be triggered instead.
// Because the compiler has determined that's not the case, it performed that neat little trick!
// this makes it useful for global functions such as length() and to_string() to be used anywhere.



